# Environment Design

The environment is the central hub of Token World, where agents, entities, and rules interact. This section explores how the environment is structured, its role in the simulation, and how it adapts dynamically based on agent actions.

---

## Key Responsibilities of the Environment

1. **Entity Management**  
   - Maintains a database of all entities in the simulation.
   - Tracks entity states and ensures they are updated based on agent actions.

2. **Action Validation**  
   - Validates actions generated by agents using preconditions and effects.
   - Ensures logical consistency between agents and the environment.

3. **Dynamic Mechanic Generation**  
   - Adapts to agent behaviors by introducing new mechanics or interactions as needed.
   - Example: Agents discovering a new area might unlock novel actions like "mine ore."

4. **State Logging**  
   - Logs all interactions, state changes, and errors for debugging and analysis.

---

## Structure of the Environment

1. **Entity Storage**  
   Entities are stored in an SQLite database for efficient querying and state management. Each entity has:
   - **Unique ID**: Identifier for the entity.
   - **Properties**: Attributes like `isEdible`, `quantity`, or `durability`.
   - **Relationships**: Links to other entities or agents.

   Example:
   ```json
   {
     "id": "tree_001",
     "name": "Tree",
     "properties": {
       "canGrowFruit": true,
       "fruitType": "Apple",
       "health": 100
     }
   }
   ```

2. **Grounding Mechanisms**  
   These ensure that agent actions are feasible by:
   - Checking entity properties and relationships.
   - Enforcing scenario-specific rules.

3. **Rules Engine**  
   Defines global constraints and dynamics:
   - **Resource Regeneration**: Rules for replenishing depleted resources.
   - **Time Steps**: Defines how the environment evolves over time.

   Example rule configuration:
   ```json
   {
     "rules": {
       "maxTimeSteps": 50,
       "resourceRegeneration": {
         "enabled": true,
         "rate": 10
       }
     }
   }
   ```

---

## Dynamic Environment Evolution

The environment evolves as agents interact with it. Examples include:
1. **New Resource Discovery**  
   Agents exploring an unknown area might trigger the addition of new resources or entities.
2. **State Propagation**  
   Changes to one entity can cascade to related entities.  
   Example: Cutting down a tree may deplete the fruit it provides.

---

## Error Handling in the Environment

1. **Missing Entities**  
   - **Scenario**: Agent references a nonexistent entity.  
   - **Response**: Logs an error and skips the action.

2. **Invalid State Changes**  
   - **Scenario**: Action attempts to modify an entity in an unsupported way.  
   - **Response**: Rejects the action and provides feedback.

---

## Extending the Environment

1. **Adding New Entity Types**  
   - Define entities with unique properties in the `config/entities.json` file.

2. **Custom Rules**  
   - Extend `config/rules.json` to add global constraints or dynamic behaviors.

3. **Environment Behaviors**  
   - Add custom logic for entity interactions in the `environment` module.

---

## Next Steps

For more insights, explore:
- [Action Validation](action_validation.md)  
- [Sub-Agent Delegation](sub_agents.md)
